obsidian://open?vault=Professional_Assembly_Language&file=Part_1%2FChapter_1_What_is_assembly_language%2F1.1_Processor_Instructions%2F1.1.2_Instruction_code_format%2F1.1.2_Instruction_code_format

# 1.1.2 指令码格式

Intel IA-32 系列微处理器包括现在IBM平台的微型计算机所使用的所有当前类型的微处理器（参见第2章），还包括流行的奔腾系列微处理器。IA-32 系列的微处理器使用专门格式的指令码，了解这些指令的格式对汇编语言程序设计将有所帮助。

---

IA-32指令码格式由四个主要部分构成：
- 可选的指令前缀
- 操作码（opcode）
- 可选的操作符
- 可选的数据元素

---

图1-2是IA-32指令码格式的布局。
![[Pasted image 20220625223802.png]]

---

每个部分都用于完整地为处理器定义要执行的特定指令。

---

Intel的奔腾处理器系列不是使用IA-32指令码格式的唯一处理器芯片系列。AMD 公司生产的一系列芯片也完全兼容 Intel IA-32 指令码格式。

---

1. 操作码

如图1-2所示，IA-32 指令码格式中唯一必须的部分是操作码。每个指令码都必须包含操作码，它定义由处理器执行的基本功能或任务。

![[Pasted image 20220625223802.png]]

操作码的长度在1到3字节之间，它唯一地定义要执行的功能。例如，2字节的操作码OF A2定义IA-32 CPUID指令。当处理器执行这个指令码时，它返回不同寄存器中关于微处理器的特定信息。然后，程序员可以使用其他的指令码从处理器寄存器中提取信息，以便确定运行程序的微处理器的类型和型号。

---

寄存器是处理器芯片之内的组件，用于临时存储处理器正在处理的数据。寄存器的详细信息将在第2章“IA-32平台”中讲解。

2. 指令前缀

指令前缀可以包含1个到4个修改操作码行为的1字节前缀。按照前缀的功能，这些前缀被分为4个组。修改操作码时，每个组的前缀一次只能使用一个（因此最多有4个前缀字节）。这4个前缀组如下：
- 锁定前缀和重复前缀
- 段覆盖前缀和分支提示前缀
- 操作数长度覆盖前缀
- 地址长度覆盖前缀

---

锁定前缀表示指令将独占地使用共享内存区域。这对于多处理器和超线程系统非常重要。

重复前缀用于表示重复的功能（常常在处理字符串时使用）。

---

段覆盖前缀定义可以覆盖定义了的段寄存器值的指令（这将在第2章中更加详细地讲解）。

分支提示前缀尝试向处理器提供程序在条件跳转语句中最可能的路径的线索（这同预报分支的硬件一起使用）。

---

操作数长度覆盖前缀通知处理器，程序将在这个操作码之内切换16位和32位的操作数长度。这使程序可以在使用大长度的操作数时警告处理器，帮助加快对寄存器的数据赋值。

地址长度覆盖前缀通知处理器，程序将切换16位和32位的内存地址。这两种长度都可以被声明为程序的默认长度，这个前缀通知处理器程序将切换到另一种长度。

3. 修饰符

![[Pasted image 20220625223802.png]]
一些操作码需要另外的修饰符来定义执行的功能中涉及到什么寄存器和内存位置。修饰符包含在 3 个单独的值中：
- 寻址方式说明符（ModR/M）字节
- 比例-索引-基址（SIB）字节
- 1、2 或者 4 个的地址移位字节

（1）ModR/M 字节
ModR/M 字节由 3 个字段的信息构成，如图1-3所示。
![[Pasted image 20220626142503.png]]
mod 字段和 r/m 字段一起使用，用于定义指令中使用的寄存器或者寻址模式。在指令之中，可能的寻址模式有 24 个，加上 8 个可以使用的通用寄存器，所以有 32 个可能值。

reg/opcode 字段用于允许使用更多的3位进一步定义操作码功能（比如操作码子功能），或者可以用于定义寄存器值。

r/m 字段用于定义用作该功能的操作数的另一个寄存器，或者可以把它和 mod 字段组合在一起定义指令的寻址模式。

（2）SIB 字节
SIB 字节也由 3 个字段的信息构成，如图1-4所示。
![[Pasted image 20220626142833.png]]
比例字段指定操作的比例因子。
索引字段指定内存访问中用作索引寄存器的寄存器。
基址字段指定用作内存访问的基址寄存器的寄存器。

ModR/M 和 SIB 字节的组合创建一个表，它可以定义用于访问数据的众多可能的寄存器组和和内存模式。Intel奔腾处理器的规范说明书定义了ModR/M 和 SIB 字节可以使用的所有可能的组合。

（3）地址移位字节
地址移位字节用来指定对于ModR/M 和 SIB 字节中定义的内存位置的偏移量。可以使用它作为基本内存位置的索引，用于存储或者访问内存之内的数据。

4. 数据元素

![[Pasted image 20220625223802.png]]
指令码的最后一部分是该功能使用的数据元素。一些指令码从内存位置或者处理器寄存器读取数据，而一些指令码在其本身之内包含数据。这个值经常被用于表示静态数字值（比如要加的数字）或者内存位置。根据数据长度，这个值可以包含 1、2 或者 4 字节的信息。

例如，下面是前面显示过的指令码的例子：
`C7 45 FC 01 00 00 00`
它定义操作码 C7，这个操作码是把值传送到内存位置的指令。内存位置由修饰符 45 FC 定义（它定义从EBP寄存器中的值（值45）指向的内存位置开始的4字节（值FC））。
最后 4 字节定义放到这个内存位置的整数值（在这个例子中这个值是 1）。

从这个例子可以看出，值 1 被写为 4 字节的十六进制值 01 00 00 00。数据流中的字节的顺序取决于使用的处理器的类型。IA-32 平台处理器使用“小尾数（little-endian）”表示法，其中低值的字节首先出现（当从左到右读时）。其他处理器使用“大尾数（big-endian）”顺序，其中高值字节首先出现。在汇编语言程序中指令数据和内存位置值时，这一概念非常重要。